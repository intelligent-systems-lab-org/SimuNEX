using System;
using UnityEngine;

/// <summary>
/// Simple fin model with constant force and torque coefficients.
/// </summary>
public class SimpleFin : Fin
{
    /// <summary>
    /// Fin angle to force factor.
    /// </summary>
    public float forceCoefficient = 1.5f;

    /// <summary>
    /// Fin angle to torque factor.
    /// </summary>
    public float torqueCoefficient = 1f;

    /// <summary>
    /// Direction of thrust generated by the primary propulsion systems.
    /// </summary>
    public Direction propulsionDirection;

    protected override void Initialize()
    {
        force = rigidBody.gameObject.AddComponent<SimpleFinForce>();
        (force as SimpleFinForce).Initialize(this);
    }
}

/// <summary>
/// Implements the FinFunction for <see cref="SimpleFin"/>
/// </summary>
public class SimpleFinForce : FinForce
{

    /// <summary>
    /// Returns the current direction of thrust generated by the primary propulsion systems.
    /// </summary>
    Func<Direction> propulsionDirection;

    /// <summary>
    /// Set up fin specific parameters.
    /// </summary>
    /// <param name="fin"><see cref="SimpleFin"/> object that the force is being applied to.</param>
    public void Initialize(SimpleFin fin)
    {
        base.Initialize(fin);
        parameters = () => new float[]
        {
            fin.forceCoefficient, fin.torqueCoefficient
        };
        propulsionDirection = () => fin.propulsionDirection;
    }

    public override float[] FinFunction(Func<float> finAngle, Func<float[]> parameters)
    {
        float _finAngle = finAngle();
        float bodySpeedSquared = Mathf.Pow(thrustSpeed, 2);

        float force = parameters()[0] * _finAngle * bodySpeedSquared;
        float torque = parameters()[1] * _finAngle * bodySpeedSquared;
        return new float[] { force, torque };
    }

    public float thrustSpeed
    {
        get {
            return propulsionDirection() switch
            {
                Direction.Left or Direction.Right => rigidBody.velocity.u,
                Direction.Forward or Direction.Backward => rigidBody.velocity.v,
                Direction.Up or Direction.Down => rigidBody.velocity.w,
                _ => 0,
            };
        }
    }
}